{"name":"Artray","body":"Getting and Running ArtRay\r\n---\r\n\r\nYou can [download a ZIP file][zipfile] or [clone the Github repository][repo] to\r\nget the code. A script, `build.sh`, is provided in the distribution for building\r\nArtRay. It will produce an executable `ar`. The executable takes two arguments:\r\nthe input scene and the output image. Input scenes are in ArtRay format, which\r\nis detailed below, and output images are always in PNG format. Any scene-related\r\noptions are set in the input file, and cannot be set on the command line.\r\n\r\nArtRay format\r\n---\r\n\r\n_Note, this section will likely be out of date by the time I finish writing it.\r\nFor more up-to-date information, see the documentation distributed with ArtRay._\r\n\r\nThe ArtRay format reads like Haskell code, but is easy to understand even for\r\nthose who are unfamiliar with Haskell syntax. There are a number of [samples][]\r\ndistributed with the code in the `scenes/` directory. I recommend looking at\r\nthese files to understand the syntax of the format, as it's very simple.\r\n\r\nThe primitives in ArtRay are colors, vectors, lists and scalars; every object in\r\na scene is built from these. Colors are expressed as a triple of fractional\r\nvalues between 0 and 1, corresponding to the red, green and blue components of\r\nthat color. Colors must be surrounded by parentheses, like so:\r\n\r\n    background = (1, 0.5, 0)\r\n\r\nThat statement would set the background color to an orange (100% red, 50% green\r\nand 0% blue).\r\n\r\nVectors are also represented by three values, but the syntax is different.\r\nUnlike colors, they shouldn't be surrounded by parenthesis, and the numbers are\r\nseparated by spaces instead of commas. They must also be proceeded by the word\r\n`Vec3`, like so:\r\n\r\n    location = Vec3 -10 0 10\r\n\r\nLists are surrounded by square brackets, and elements in a list are separated by\r\ncommas. Newlines can also be placed between elements in lists, but are optional.\r\nAn example of a list is shown below:\r\n\r\n    colors = [\r\n      (0, 1, 0),\r\n      (1, 0, 0)\r\n    ]\r\n\r\n## Scenes\r\nThe top-level object in any scene is a `Scene`, which has five fields,\r\n`background`, `options`, `geom`, `lights` and `viewer`, each of which are\r\nrequired. The current parser requires that these fields be in order -- future\r\nversions of ArtRay will eliminate this requirement.\r\n\r\n### Scene Options\r\nAn ArtRay scene has an (optionally empty) list of options in its `options`\r\nfield. At the moment there are only two options: `GlobalAmbient` and\r\n`Antialiased`. Sample syntax is shown in the snippet below:\r\n\r\n    options = [\r\n      GlobalAmbient (0.4, 0.4, 0.4),\r\n      Antialiased 4\r\n    ]\r\n\r\n`GlobalAmbient` takes the global ambient color as it's one argument (this will\r\nbe explained further in the Lighting section below).\r\n\r\nAntialiasing is done using MSAA. The `Antialiased` option takes a single\r\nargument, which corresponds to the number of subpixels per dimension that will\r\nbe sampled, so an argument of 4 corresponds to MSAAx4, or 16 subpixels per\r\npixel. In general, a higher subpixel count means better antialiasing and longer\r\nruntime.\r\n\r\n## Geometry\r\nThe geometry of a scene is a list of geometric primitives. ArtRay only supports\r\ntwo kinds of geometric primitives: spheres and half-planes.  Each kind of\r\nprimitive has a material associated with it.\r\n \r\nSpheres are defined by a center (a vector), a radius (a scalar) and a material.\r\nThe syntax for a red sphere with center (10, 0, 0) and a radius of 1 is shown\r\nbelow:\r\n\r\n    Sphere {\r\n      center = Vec3 10 0 0,\r\n      radius = 1.0,\r\n      material = ColorMaterial (1, 0, 0)\r\n    }\r\n\r\nPlanes are defined by a vector on the plane and the normal vector of the plane.\r\nNote that the \"plane\" primitive is actually a half-plane: it will only reflect\r\nlight from the side the normal points towards. This means that if you use a more\r\ncomplex material for it (i.e., anything that isn't a `ColorMaterial`) only one\r\nface will be lit correctly. To create a plane that reflects light from both\r\nsides, add another plane to the scene with the same position vector and a\r\nnegated normal vector. The syntax for a blue yz-plane where x=8 is as follows:\r\n\r\n    Plane {\r\n      pnorm = Vec3 -1 0 0,\r\n      point = Vec3 8 0 0,\r\n      material = ColorMaterial (0, 0, 1)\r\n    }\r\n\r\n## Lights and Materials\r\nThere are two lighting models available in ArtRay. One has no shading and no\r\nlighting at all -- a primitive that uses this lighting model has one color over\r\nthe entire body, and is flatly shaded. To use this lighting model on a\r\nprimitive, assign a `ColorMaterial` to that primitive. `ColorMaterial` takes one\r\nargument, which is the color of the primitive.\r\n\r\nFor realistic lighting, ArtRay uses [Phong reflectance][phong]. This decomposes\r\nlight and materials into three portions: specular, diffuse and ambient. ArtRay\r\nsimplifies this model somewhat -- instead of allowing each light to contribute\r\nto ambient, there is just one global ambient applied to the scene. This is set\r\nusing the `GlobalAmbient` option described in the Options section. Each light\r\nhas two parameters: `speclight`, the specular color of the light, and\r\n`difflight`, the diffuse color of the light. Each light also has a location\r\nstored in the `loclight` field. `PhongMaterial`, has four fields: `specular`,\r\n`diffuse`, `ambient`, and `phongexp`. `specular`, `diffuse` and `ambient` are\r\nthe corresponding color components of the material. `phongexp` is the Phong\r\nexponent of the material -- this effects the size of the specular highlights on\r\nthe object. The higher the exponent, the brighter and smaller the highlights\r\nwill be. The geometry and lights sections from a scene that uses Phong lighting\r\nis shown below:\r\n\r\n    geom = [\r\n      Sphere {\r\n        center = Vec3 10.0 0.0 0.0,\r\n        radius = 1.0,\r\n        material = PhongMaterial {\r\n          specular = (1.0, 1.0, 1.0),\r\n          diffuse = (0.0, 0.7, 0.0),\r\n          ambient = (0.0, 1.0, 0.0),\r\n          phongexp = 4 \r\n        } \r\n      }\r\n    ],\r\n\r\n    lights = [\r\n      PhongLight {\r\n        speclight = (1.0, 1.0, 1.0),\r\n        difflight = (1.0, 1.0, 1.0),\r\n        loclight = Vec3 6.0 4.0 0.0 \r\n      }\r\n    ]\r\n\r\n## Viewer\r\nThe `Viewer` of the scene defines the \"camera\" viewing the scene. It is\r\nparameterized by four vectors: `location`, `u`, `v` and `f`. `location` is a\r\nvector which is the location of the imaginary camera. `u`, `v` and `f` are\r\nslightly more difficult concepts to describe. In order to determine what in the\r\nscene the camera can see, ArtRay simulates an actual camera of sorts. This\r\ncamera has a \"focal length\" `f`. In reality, `f` is a vector that points from\r\nthe camera's location to the location of the center of it's \"image plane\" --\r\nthink of this as the direction that the camera is looking. `v` is the vector\r\nthat points up, and it's length determines how much of the scene the camera can\r\nsee vertically. Making `v` longer means that more of the scene can be seen in\r\nthe vertical direction. `u` is the horizontal equivalent to `v`, and should be\r\northogonal to `v`. Again, the longer `u` is, the more can be seen in the\r\nhorizontal direction.\r\n\r\nNote that the wider you make `u` and `v`, or the shorter `f` is, the more\r\n\"barrel warp\" you will see in the image. If you want to see more without\r\ndistortion, you will need to move the camera itself further away from the scene.\r\n\r\n[phong]: http://en.wikipedia.org/wiki/Phong_reflection_model\r\n[repo]: https://github.com/haldean/artray\r\n[samples]: https://github.com/haldean/artray/tree/master/scenes\r\n[zipfile]: https://github.com/haldean/artray/zipball/master","tagline":"A ray tracer in Haskell","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}